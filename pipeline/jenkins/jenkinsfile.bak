#!/usr/bin/env groovy
// Pipeline Syntax
// ref: https://jenkins.io/doc/book/pipeline/syntax/
// all available buit-in environment variables.
// ref: http://jenkins.hugeman.co/env-vars.html/

pipeline {
    // (pipeline) Declarative environment variable,
    environment {
        CI_GITHUB_REPOSITORY_NAME = "${sh(script:"basename $GIT_URL .git", returnStdout: true).trim()}"
        CI_DOCKER_REGISTRY_NAME = credentials('JK_DOCKER_REGISTRY_NAME')
        CI_GITHUB_ACCESS_TOKEN = credentials('JK_GITHUB_ACCESS_TOKEN')
        CI_GITHUB_ORGANIZATION = credentials('JK_GITHUB_ORGANIZATION')
        CI_GITHUB_GITOPS_REPO = credentials('JK_GITHUB_GITOPS_REPO')
        CI_GITHUB_EMAIL = credentials('JK_GITHUB_EMAIL')
        CI_GITHUB_USER = credentials('JK_GITHUB_USER')
        CI_SYNK_TOKEN = credentials('JK_SYNK_TOKEN')
        CI_SONARQUBE_PROJECT_KEY = credentials('JK_SONARQUBE_PROJECT_KEY')
    }
    // this is a YAML representation of the Pod, to allow setting any values not supported as fields.
    // pod available: dind-awscli
    agent {
        kubernetes {
            // declarative agents can be defined from YAML.
            yamlFile "pipeline/jenkins/podTemplate.yaml"
        }
    }
    // to do actions
    stages {
        // checkout source code version
        stage('checkout-scm') {
            steps {
                checkout(scm)
        }
    }
        // prepare environment variable
        stage('preparation-environment-variable') {
            parallel {
                stage('prepare-feature-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /feature\/[a-zA-Z]+.\d+.[a-zA-Z]+.*/ // e.g: feature/hcd-456-foo
                        }
                    }
                    steps {
                        script {
                            // (pipeline) Declarative environment variable
                            env.CI_BRANCH_ENVIRONMENT = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f1", returnStdout: true).trim()}"
                            env.CI_GITHUB_FEATURE_VERSION = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f 2-5", returnStdout: true).trim()}" 
                        }
                    }
                }
                stage('prepare-develop-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /develop/
                        }
                    }
                    steps{
                        script {
                            // (pipeline) Declarative environment variable
                            env.CI_BRANCH_ENVIRONMENT = "${sh(script:"echo $BRANCH_NAME", returnStdout: true).trim()}"
                            env.CI_GITHUB_FEATURE_VERSION = "${sh(script:"git log --merges --pretty=format:'%s' -1 | tr '[:upper:]' '[:lower:]' | grep 'feature' | cut -d/ -f3", returnStdout: true).trim()}"
                        }
                    }
                }
                stage('prepare-release-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /release\/\d+\.\d+\.\d+/ // e.g: release/1.0.0
                        }
                    }
                    steps{
                        script {
                            // (pipeline) Declarative environment variable
      	                    env.CI_BRANCH_ENVIRONMENT = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f1", returnStdout: true).trim()}"
      	                    env.CI_GITHUB_RELEASE_VERSION = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f2", returnStdout: true).trim()}"
                        }
                    }
                }
                stage('prepare-master-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /master/ // e.g master
                        }
                    }
                    steps{
                        script {
                            // (pipeline) Declarative environment variable
			    env.GITOPS_BRANCH_ENVIRONMENT_PRIMARY = "pre-production"
			    env.GITOPS_BRANCH_ENVIRONMENT_SECONDARY = "production"
			    env.CI_GTIHUB_PROD_VERSION = "${sh(script:"git log --merges --pretty=format:'%s' -1 | tr '[:upper:]' '[:lower:]' | grep 'release' | cut -d/ -f3", returnStdout: true).trim()}"
                        }
                    }
                }
                stage('prepare-hotfix-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /hotfix\/[a-zA-Z]+.\d+.[a-zA-Z]+.*/ // e.g: hotfix/hcd-789-bar
                          }
                    }
                    steps{
                        script {
                            // (pipeline) Declarative environment variable
      	                    env.CI_BRANCH_ENVIRONMENT = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f1", returnStdout: true).trim()}"
                            env.CI_GTIHUB_HOTFIX_VERSION = "${sh(script:"git log --merges --pretty=format:'%s' -1 | tr '[:upper:]' '[:lower:]' | grep 'hotfix' | cut -d/ -f3", returnStdout: true).trim()}"
                        }
                    }
                }
                stage('prepare-bugfix-environment') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /bugfix\/[a-zA-Z]+.\d+.[a-zA-Z]+.*/ // e.g: bugfix/hcd-789-bar
                          }
                    }
                    steps{
                        script {
                            // (pipeline) Declarative environment variable
      	                    env.CI_BRANCH_ENVIRONMENT = "${sh(script:"echo $BRANCH_NAME | cut -d/ -f1", returnStdout: true).trim()}"
                        }
                    }
                }
            }
        }
        // authen docker registry 
        stage('authentication-docker-registry') {
            when {
                expression {
                    env.CI_BRANCH_ENVIRONMENT ==~ /feature|develop|release|hotfix|bigfix/ 
                }
            }
            steps{
                container('dind-awscli') {
                    withCredentials([[
                       $class: 'AmazonWebServicesCredentialsBinding',
                       credentialsId: "JK_DOCKER_REGISTRY_TOKEN",
                       accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                       secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                       sh 'aws ecr get-login-password --region ap-southeast-1 | docker login --username AWS --password-stdin ${CI_DOCKER_REGISTRY_NAME}'
                    }
                }
            }
            post {
                failure {
                    slackSend channel: '#test-template-golang-clean-arch', 
                              color: "danger",
                              message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                }
            }
        }
        // authen snyk
        stage('authentication-snyk') {
            when {
                expression {
                    env.CI_BRANCH_ENVIRONMENT ==~ /feature|develop|release|hotfix|bugfix/ 
                }
            }
            steps{
                container('dind-awscli') {
                    sh 'snyk auth ${CI_SYNK_TOKEN}'
                }
            }
            // when dind snyk authen success, also java's agent as well for provides scaning dependency stage
            post {
                success {
                    script {
                        container('java') {
                            sh 'snyk auth ${CI_SYNK_TOKEN}'
                        }
                    }
                } 
                failure {
                    slackSend channel: '#test-template-golang-clean-arch', 
                              color: "danger",
                              message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                }
            }
        }
        // unit-tests
        stage('unit-tests') {
            parallel {
                stage('unit-tests-feature') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /feature/
                        }
                    }
                    steps{
                        container('java') {
                            withCredentials([file(credentialsId: 'JK_FEAT_ENVS', variable: 'envs'),
			                     file(credentialsId: 'JK_FIREBASE_CONFIG', variable: 'firebase_config')]) {
    		            // install dependencies
            	            sh "make project/install/package"
    		            // generate l10n
    		            sh "make l10n/generate"
    		            // Generate mock file for test
    		            sh "make test/generate/mock-file"
    		            // Create file env
			    sh "cat ${envs} > .env"
    		            // Create filebase config file
			    sh "cat ${firebase_config} > web/firebase-config-service.js"
    		            // Test (Unit test & Widjet test)
    		            sh "make test/run"
    		            // Test coverage report
    		            sh "make test/generate/coverage-report"
    		            // Test coverage score
    		            sh "make test/check/coverage-score"
    		            // Analysis
    		            sh "make analysis/run"
    		            // Integration test web
    		            //sh "make integration-test/run/web"
                            // Chromedrvier as background
    			    sh "chromedriver --port=4444 &"
                            // Run Integration test web
    			    sh "flutter drive --driver=test_driver/integration_test.dart --target=integration_test/main_integration_test.dart -d web-server"
			    // build static files
			    sh "make web/build"
			    }
                        }
                    }
                }
                stage('unit-tests-develop') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /develop|bugfix/
                        }
                    }
                    steps{
                        container('java') {
                            withCredentials([file(credentialsId: 'JK_DEV_ENVS', variable: 'envs'),
			                     file(credentialsId: 'JK_FIREBASE_CONFIG', variable: 'firebase_config')]) {
    		            // install dependencies
            	            sh "make project/install/package"
    		            // generate l10n
    		            sh "make l10n/generate" // Output file: root_project/lib/src/configs/l10n/app_localizations*.dart
    		            // Generate mock file for test
    		            sh "make test/generate/mock-file" // Output file: root_project/test  filename *.mocks.dart
    		            // Create file env
			    sh "cat ${envs} > .env"
    		            // Create filebase config file
			    sh "cat ${firebase_config} > web/firebase-config-service.js"
    		            // Test (Unit test & Widjet test)
    		            sh "make test/run"
    		            // Test coverage report
    		            sh "make test/generate/coverage-report"
    		            // Test coverage score
    		            sh "make test/check/coverage-score"
    		            // Analysis
    		            sh "make analysis/run"
    		            // Integration test web
    		            //sh "make integration-test/run/web"
                            // Chromedrvier as background
    			    sh "chromedriver --port=4444 &"
                            // Run Integration test web
    			    sh "flutter drive --driver=test_driver/integration_test.dart --target=integration_test/main_integration_test.dart -d web-server"
			    // build static files
			    sh "make web/build"
			    }
                        }
                    }
                }
                stage('unit-tests-release') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /release|hotfix/
                        }
                    }
                    steps{
                        container('java') {
                            withCredentials([file(credentialsId: 'JK_RELEASE_ENVS', variable: 'envs'),
			                     file(credentialsId: 'JK_FIREBASE_CONFIG', variable: 'firebase_config')]) {
    		            // install dependencies
            	            sh "make project/install/package"
    		            // generate l10n
    		            sh "make l10n/generate" // Output file: root_project/lib/src/configs/l10n/app_localizations*.dart
    		            // Generate mock file for test
    		            sh "make test/generate/mock-file" // Output file: root_project/test  filename *.mocks.dart
    		            // Create file env
			    sh "cat ${envs} > .env"
    		            // Create filebase config file
			    sh "cat ${firebase_config} > web/firebase-config-service.js"
    		            // Test (Unit test & Widjet test)
    		            sh "make test/run"
    		            // Test coverage report
    		            sh "make test/generate/coverage-report"
    		            // Test coverage score
    		            sh "make test/check/coverage-score"
    		            // Analysis
    		            sh "make analysis/run"
    		            // Integration test web
    		            //sh "make integration-test/run/web"
                            // Chromedrvier as background
    			    sh "chromedriver --port=4444 &"
                            // Run Integration test web
    			    sh "flutter drive --driver=test_driver/integration_test.dart --target=integration_test/main_integration_test.dart -d web-server"
			    // build static files
			    sh "make web/build"
			    }
                        }
	            }
                }
	    }
	}
        // thrid party dependency analysis 
        stage('thrid-party-dependency-analysis') {
            when {
                expression {
                    env.CI_BRANCH_ENVIRONMENT ==~ /feature|develop|release|hotfix|bugfix/ 
                }
            }
            steps{
                container('dind-awscli') {
                    echo 'snyk dependency scaning..'
                    // sh 'snyk test --project-name=${CI_GITHUB_REPOSITORY_NAME} --project-environment=${CI_BRANCH_ENVIRONMENT} --severity-threshold=low'
                }
            }
            post {
                failure {
                    slackSend channel: '#test-template-golang-clean-arch', 
                              color: "danger",
                              message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                }
            }
        }
        // build dockerize
        stage('build-service') {
            parallel {
                stage('build-feature-service') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /feature/
                        }
                    }
                    steps{
                        container('dind-awscli') {
                            sh 'docker build . --tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} --network=host'
                        }
                    }
                // when build success, will declare environment variable for provides to deployment stage
                post {
                    success {
                        script {
                            // declarative environment variable
                            env.GITOPS_BRANCH_ENVIRONMENT = "feat"
                            env.GITOPS_SERVICE_NAME = "${sh(script:"echo $CI_GITHUB_REPOSITORY_NAME", returnStdout: true).trim()}"
                            env.GITOPS_DOCKER_BRANCH_TAG = "${sh(script:"echo $CI_BRANCH_ENVIRONMENT", returnStdout: true).trim()}"
                            env.GITOPS_DOCKER_FEATURE_TAG = "${sh(script:"echo $CI_GITHUB_FEATURE_VERSION", returnStdout: true).trim()}"
                            }
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('build-develop-service') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /develop|bugfix/
                        }
                    }
                    steps{
                        container('dind-awscli') {
                            sh 'docker build . --tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} --network=host'
                        }
                    }
                // when build success, will declare environment variable for provides to deployment stage
                post {
                    success {
                        script {
                            // declarative environment variable
                            env.GITOPS_BRANCH_ENVIRONMENT = "dev"
                            env.GITOPS_SERVICE_NAME = "${sh(script:"echo $CI_GITHUB_REPOSITORY_NAME", returnStdout: true).trim()}"
                            env.GITOPS_DOCKER_BRANCH_TAG = "${sh(script:"echo $CI_BRANCH_ENVIRONMENT", returnStdout: true).trim()}"
                            }
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('build-release-service') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /release|hotfix/
                        }
                    }
                    steps{
                        container('dind-awscli') {
                            sh 'docker build . -tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} --network=host'
                        }
                    }
                // when build success, will declare environment variable for provides to deployment stage
                post {
                    success {
                        script {
                            // Declarative environment variable
                            env.GITOPS_BRANCH_ENVIRONMENT_PRIMARY = "staging"
                            env.GITOPS_BRANCH_ENVIRONMENT_SECONDARY = "uat"
                            env.GITOPS_SERVICE_NAME = "${sh(script:"echo $CI_GITHUB_REPOSITORY_NAME", returnStdout: true).trim()}"
                            env.GITOPS_DOCKER_BRANCH_TAG = "${sh(script:"echo $CI_BRANCH_ENVIRONMENT", returnStdout: true).trim()}"
                            env.GITOPS_DOCKER_RELEASE_TAG = "${sh(script:"echo $CI_GITHUB_RELEASE_VERSION", returnStdout: true).trim()}"
                            }
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
            }
        }
        // trigger github workflows
        stage('trigger-github-workflows') {
            parallel {
                stage('trigger-github-workflows') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /feature|develop|release|master|bugfix|hotfix/
                        }
                    }
                    steps{
		        sh "echo 'android\nios\n' > devices.txt"
                        sh '''#!/bin/bash
			      set -x
			      github_access_token=$(echo ${CI_GITHUB_ACCESS_TOKEN})
			      github_organization=$(echo ${CI_GITHUB_ORGANIZATION})
			      github_repository=$(echo ${CI_GITHUB_REPOSITORY_NAME})
			      github_branch=$(echo ${BRANCH_NAME})
			      environment=$(echo ${CI_BRANCH_ENVIRONMENT})
			      gitops_environment=$(echo ${GITOPS_BRANCH_ENVIRONMENT})
			      device=(cat devices.txt)
			      while read -r device; do
                                curl -X POST \
                                -H "Authorization: token ${github_access_token}" \
                                -H "Accept: application/vnd.github.v3+json" \
                                https://api.github.com/repos/${github_organization}/${github_repository}/actions/workflows/fastlane-${device}.yaml/dispatches \
				-d '{"ref":"'"${github_branch}"'", "inputs": { "apiUrl": "https://sandbox.hugeman.co/'"${gitops_environment}"'/template-golang-clean-arch/api/v1", "ssrUrl": "https://sandbox.hugeman.co/'"${gitops_environment}"'/template-golang-clean-arch/api/sse/v1", "grpcWebScheme": "https", "grpcWebDomain": "sandbox.hugeman.co", "grpcWebPort": "8083", "grpcMobileDomain": "sandbox.hugeman.co", "grpcMobilePort": "8083", "branch": "'"${environment}"'" } }'
			      done <  <(cat devices.txt)
			'''
                    }
                post {
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
            }
        }
        // image security analysis 
        stage('image-security-analysis') {
            when {
                expression {
		    env.CI_BRANCH_ENVIRONMENT ==~ /feature|develop|release|hotfix|bugfix/
                }
            }
            steps{
                container('dind-awscli') {
                    //sh 'snyk container test ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} --project-name=${CI_GITHUB_REPOSITORY_NAME} --project-environment=${CI_BRANCH_ENVIRONMENT} --severity-threshold=low'
     	            echo "image-security-analysis-feature.."
                }
            }
            post {
                failure {
                    slackSend channel: '#test-template-golang-clean-arch', 
                              color: "danger",
                              message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                }
            }
        }
        // push dockerize to aws ecr
        stage('push-dockerize-to-aws-ecr') {
            parallel {
                stage('push-dockerize-to-aws-ecr-feature') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /feature/
                        }
                    }
                    steps{
                        container('dind-awscli') {
			    sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER}'
			    sh 'docker tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_FEATURE_VERSION}-${BUILD_NUMBER}'
			    sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_FEATURE_VERSION}-${BUILD_NUMBER}'
                        }
                    }
                post {
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('push-dockerize-to-aws-ecr-develop') {
                    when {
                        expression {
                            env.BRANCH_NAME ==~ /develop|bugfix/
                        }
                    }
                    steps{
                        container('dind-awscli') {
			    sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER}'
                        }
                    }
                post {
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('push-dockerize-to-aws-ecr-release') {
                    when {
                        expression {
                            env.CI_BRANCH_ENVIRONMENT ==~ /release|hotfix/
                        }
                    }
                    steps{
                        container('dind-awscli') {
                            sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER}'
                            sh 'docker tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${BUILD_NUMBER} ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION}'
                            sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION}'
                            sh 'docker tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION} ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION}-${BUILD_NUMBER}'
                            sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION}-${BUILD_NUMBER}'
                            sh 'docker tag ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_BRANCH_ENVIRONMENT}-${CI_GITHUB_RELEASE_VERSION}-${BUILD_NUMBER} ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_GITHUB_RELEASE_VERSION}'
                            sh 'docker push ${CI_DOCKER_REGISTRY_NAME}/${CI_GITHUB_REPOSITORY_NAME}:${CI_GITHUB_RELEASE_VERSION}'
                        }
                    }
                post {
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
            }
        }
        // deployment application
        stage('deployment') {
            parallel {
                stage('deployment-feat') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT ==~ /feat/
                        }
                    }
                    steps{
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '${GITOPS_DOCKER_BRANCH_TAG}-.*'/tag: '${GITOPS_DOCKER_BRANCH_TAG}-${GITOPS_DOCKER_FEATURE_TAG}-${BUILD_NUMBER}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${GITOPS_DOCKER_BRANCH_TAG}-${GITOPS_DOCKER_FEATURE_TAG}-${BUILD_NUMBER}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")
                    }
                post {
                    success {
                        slackSend channel: '#test-template-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('deployment-dev') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT ==~ /dev/
                        }
                    }
                    steps{
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '${GITOPS_DOCKER_BRANCH_TAG}-.*'/tag: '${GITOPS_DOCKER_BRANCH_TAG}-${BUILD_NUMBER}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${GITOPS_DOCKER_BRANCH_TAG}-${BUILD_NUMBER}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")
                    }
                post {
                    success {
                        slackSend channel: '#test-template-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('deployment-staging') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT_PRIMARY ==~ /staging/
                        }
                    }
                    steps{
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT_PRIMARY}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '${GITOPS_DOCKER_BRANCH_TAG}-.*'/tag: '${GITOPS_DOCKER_BRANCH_TAG}-${GITOPS_DOCKER_RELEASE_TAG}-${BUILD_NUMBER}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${GITOPS_DOCKER_BRANCH_TAG}-${GITOPS_DOCKER_RELEASE_TAG}-${BUILD_NUMBER}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT_PRIMARY} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")

                    }
                post {
                    success {
                        slackSend channel: '#test-flutter-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-flutter-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('deployment-uat') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT_SECONDARY ==~ /uat/
                        }
                    }
                    steps{
                        sleep 30
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT_SECONDARY}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '${GITOPS_DOCKER_BRANCH_TAG}-.*'/tag: '${GITOPS_DOCKER_BRANCH_TAG}'-'${GITOPS_DOCKER_RELEASE_TAG}-${BUILD_NUMBER}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${GITOPS_DOCKER_BRANCH_TAG}-${GITOPS_DOCKER_RELEASE_TAG}-${BUILD_NUMBER}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT_SECONDARY} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")
                    }
                post {
                    success {
                        slackSend channel: '#test-template-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('deployment-pre-production') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT_PRIMARY ==~ /pre-production/
                        }
                    }
                    steps{
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT_PRIMARY}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '[0-9].[0-9].[0-9]'/tag: '${CI_GTIHUB_PROD_VERSION}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${CI_GTIHUB_PROD_VERSION}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT_PRIMARY} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")
                    }
                post {
                    success {
                        slackSend channel: '#test-template-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
                stage('deployment-production') {
                    when {
                        expression {
                            env.GITOPS_BRANCH_ENVIRONMENT_SECONDARY ==~ /production/ 
                        }
                    }
                    steps{
                        sleep 30
                        sh "git clone https://${CI_GITHUB_ACCESS_TOKEN}@github.com/${CI_GITHUB_ORGANIZATION}/${CI_GITHUB_GITOPS_REPO}.git --branch ${GITOPS_BRANCH_ENVIRONMENT_SECONDARY}"
                        sh "git config --global user.email \"${CI_GITHUB_EMAIL}\""
                        sh "git config --global user.name \"${CI_GITHUB_USER}\""
                        sh ("""cd ${CI_GITHUB_GITOPS_REPO} && \
                        sed -i 's/tag: '[0-9].[0-9].[0-9]'/tag: '${CI_GTIHUB_PROD_VERSION}'/g' application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git add application/${GITOPS_SERVICE_NAME}/application/helm/values.yaml && \
                        git diff-index --quiet HEAD || git commit --message \"[Bot] Updated application helm values: ${CI_GTIHUB_PROD_VERSION}\" && \
                        git push --set-upstream origin ${GITOPS_BRANCH_ENVIRONMENT_SECONDARY} && \
			cd ../ && rm -rf ${CI_GITHUB_GITOPS_REPO}""")
                    }
                post {
                    success {
                        slackSend channel: '#test-template-golang-clean-arch', 
			          color: "good",
                                  message: "*Jenkins pipelines status*: success\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    failure {
                        slackSend channel: '#test-template-golang-clean-arch', 
                                  color: "danger",
                                  message: "*Jenkins pipelines status*: failure\n *Branch*: ${env.BRANCH_NAME}\n *Commit:* ${env.GIT_COMMIT}\n *Stage* ${env.STAGE_NAME}\n *Workflow URL:* ${env.BUILD_URL}"
                        }
                    }
                }
            }
        }
    }
}
